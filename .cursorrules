# Cursor AI — Project Rules

Follow these rules for all code generation and edits in this repo.

---

## Database Queries

- **ALWAYS** use explicit field selection (never `SELECT *` or `.select('*')`).
- **ALWAYS** scope by `project_id` when querying tasks.
- **ALWAYS** scope by `owner_id` or `user_id` when querying user-owned data.
- **ALWAYS** use RPC functions for multi-step operations that must be atomic.

---

## Server Actions

- **ALWAYS** use the `'use server'` directive in server action files.
- **ALWAYS** call `revalidatePath` (or `revalidateTag`) after mutations — never rely on manual refetch (e.g. no `load*()` after an action in the same handler).
- **NEVER** use `createClient()` from `@/lib/supabase/client` in components. Use server actions or server components with `@/lib/supabase/server` only.

---

## Data Loading (CRITICAL)

- **ALWAYS** fetch initial page data in Server Components (page.tsx)
- **NEVER** use useEffect to fetch data on component mount
- **ALWAYS** wrap read-only server actions with React cache()
- **ALWAYS** pass data to client components as props

### Pattern

```typescript
// page.tsx (Server Component)
export default async function Page() {
  const data = await getDataAction() // ← Server-side
  return <PageClient initialData={data} />
}

// actions.ts
import { cache } from 'react'
export const getDataAction = cache(async () => { ... })

// PageClient.tsx
'use client'
export default function PageClient({ initialData }) {
  const [data, setData] = useState(initialData) // ← From props
  // NO useEffect to fetch initial data
}
```

### Forbidden

```typescript
// ❌ NEVER DO THIS
'use client'
export default function Page() {
  useEffect(() => {
    fetchData() // ❌ FORBIDDEN for initial page data
  }, [])
}
```

### Before Generating ANY Page Component

1. Check: Is this initial page data? → Fetch server-side
2. Check: Is action read-only? → Wrap with cache()
3. Check: Does client need data? → Pass as props
4. NEVER create useEffect for initial data fetch

Refer to: docs/patterns/data-loading.md

---

## Context Session Cache

When building or changing routes where the user can **return** to an already-visited context (e.g. project + tabs: board, notes, ideas, budgets, todos):

- **Do not refetch** data the user already loaded in this session when they navigate back. Use a **client-side session cache** keyed by context + data type (e.g. `project:${id}`, `board:${id}`).
- **Provider placement (critical):** The cache provider must live in a layout that **stays mounted** when the user switches between contexts (e.g. between projects). Put it in the **parent** layout (e.g. `app/context/layout.tsx`), **not** inside the dynamic segment layout (e.g. not only in `app/context/[projectId]/layout.tsx`), or the cache is lost on navigation.
- **Pattern:** Use a `*FromCache` wrapper per view that: on cache hit → render with cached data; on cache miss → loading state, fetch (server action), then set cache and render. Pass `onRefresh` so mutations can invalidate and refetch that key.
- **After mutations:** Invalidate the affected cache key (and refetch if the user stays on that view) so the UI stays in sync; avoid full page refresh when possible.

Refer to: docs/patterns/context-session-cache.md and docs/context-session-cache-discovery.md

---

## Loading States (CRITICAL)

- **ALWAYS** use a **shimmer effect** for loading states (skeleton placeholders with shimmer animation).
- **NEVER** use spinners or the text "Loading..." (or similar) for loading. Shimmer keeps the UI feeling fluid and consistent.
- On cache miss or initial load, show shimmer placeholders that match the layout of the real content; when data arrives, replace with content. No full-page loading overlays.

---

## Cache and Fetches

- **ALWAYS** use cache where the user can return to the same context (e.g. project tabs): session cache so we do **not** refetch data already loaded in the session.
- **NEVER** trigger unnecessary fetches: prefer cache hit → render from cache; on mutations, update UI from returned data or invalidate cache + single refetch in the wrapper — no manual `load*()` after an action.

---

## Insert/Update: No Refresh in UI

- **NEVER** use `router.refresh()` or full-page reload after insert or update.
- After a mutation: update the UI using the **data returned** from the server action, or call **onRefresh** (invalidate cache + refetch in the wrapper) so the list/detail updates without any page refresh. The UI must feel instant; no loading spinner overlay for the whole view.

---

## Code Style and Formatting

- **ALWAYS** match the project’s Prettier config (`.prettierrc`): semicolons, single quotes, `tabWidth: 2`, `trailingComma: "es5"`.
- **After generating or editing code**, run `npx prettier --write <edited-files>` (or `npx prettier --write .` for many files) so the pre-commit `format:check` passes and the user can commit without re-running Prettier.

---

## Before Generating Code

1. **Check** `docs/patterns/` for the relevant pattern (server-actions.md, database-queries.md, transactions.md, context-session-cache.md).
2. **Use** `templates/` for boilerplate (server-action.template.ts, rpc-function.template.sql, optimistic-update.template.ts).
3. **Follow** CURSOR_RULES.md strictly when it exists in the repo.
4. **If adding or changing routes/views in a context that uses session cache** (e.g. `/context/[projectId]/...`): follow docs/patterns/context-session-cache.md and keep the cache provider in the parent layout so cache persists when switching contexts.
5. **Loading states:** Always use **shimmer** (skeleton with shimmer animation). Never use spinners or "Loading..." text. Use cache to avoid unnecessary fetches; never refresh the whole UI after insert/update — use returned data or onRefresh.

**Reference `docs/patterns/` before every code generation.**
